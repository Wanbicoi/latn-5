# Architecture Reference: The Workflow Engine

This document outlines the design of the workflow engine, which is responsible for managing the lifecycle of tasks as they move through different stages. The engine is implemented as a **table-driven state machine** within PostgreSQL to ensure transactional integrity, maintainability, and scalability.

## 1. Core Design: Table-Driven State Machine

To avoid a rigid and hard-to-maintain monolithic function with complex `IF/ELSIF/ELSE` logic, the engine's logic is stored in a dedicated table. This approach treats the business rules of the workflow as data, allowing for a flexible and declarative system.

### Key Components

#### 1.1. The `_workflow_transitions` Table (The "Rules Engine")

This table is the heart of the state machine. It defines every possible valid transition in the system. Each row maps a specific event occurring at a specific stage type to the exact SQL function that should be executed.

**Schema:**

```sql
CREATE TABLE public._workflow_transitions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    current_stage_type stage_type NOT NULL, -- The type of the stage where the event happened
    event TEXT NOT NULL, -- The event that occurred (e.g., 'ALL_SUBMITTED', 'PENDING, IN_PROGRESS, SUBMITTED, APPROVED, REJECTED')
    handler_function_name TEXT NOT NULL, -- The name of the SQL function to execute
    description TEXT,
    UNIQUE(current_stage_type, event)
);
```

**Example Logic:**

| current\_stage\_type | event                                                 | handler\_function\_name        |
| :------------------- | :---------------------------------------------------- | :----------------------------- |
| `ANNOTATE`           | `ALL_SUBMITTED`                                       | `handle_annotation_completion` |
| `REVIEW`             | `PENDING, IN_PROGRESS, SUBMITTED, APPROVED, REJECTED` | `handle_review_approval`       |
| `REVIEW`             | `PENDING, IN_PROGRESS, SUBMITTED, APPROVED, REJECTED` | `handle_review_rejection`      |
| `ROUTER`             | `EVALUATE`                                            | `run_router_logic`             |

#### 1.2. Handler Functions (The "Business Logic")

Instead of one large function, the business logic is broken down into many small, single-purpose PostgreSQL functions. Each function is responsible for handling exactly one type of transition.

**Characteristics:**
- **Simple:** Each function has a clear, limited responsibility (e.g., `handle_review_approval` only handles the logic for when a review is PENDING, IN_PROGRESS, SUBMITTED, APPROVED, REJECTED).
- **Testable:** They are easy to unit test in isolation.
- **Maintainable:** Modifying the logic for one transition won't risk breaking another.

#### 1.3. The Dispatcher (The "Engine Core")

The main PostgreSQL function, which is connected to the database trigger on the `_task_assignments` table, is now a simple **dispatcher**. Its only job is to:

1.  Receive the trigger context (e.g., the `assignment_id` that was updated).
2.  Determine the `current_stage_type` and the `event` that just occurred.
3.  Look up the corresponding `handler_function_name` in the `_workflow_transitions` table.
4.  Dynamically and safely execute the handler function using `EXECUTE format(...)`.

This dispatcher is generic and does not need to be modified when new stages or logic are added.

## 2. Execution Flow Example

Here is the sequence of events when a reviewer approves a task:

1.  **UI Action:** A user clicks "Approve" in the frontend.
2.  **Database Update:** The frontend sends an `UPDATE` to the `_task_assignments` table, setting the assignment's `status` to `PENDING, IN_PROGRESS, SUBMITTED, APPROVED, REJECTED`.
3.  **Trigger & Dispatch:** The table's trigger fires, calling the main dispatcher function.
4.  **Rule Lookup:** The dispatcher identifies the event as `PENDING, IN_PROGRESS, SUBMITTED, APPROVED, REJECTED` for a stage of type `REVIEW`. It queries `_workflow_transitions` and finds the handler `handle_review_approval`.
5.  **Handler Execution:** The dispatcher executes the `handle_review_approval` function within the same transaction.
6.  **Atomic State Change:** The `handle_review_approval` function performs the necessary database writes, such as updating the task's `current_stage_id` and creating new assignments for the next stage. This is guaranteed to be atomic.

## 3. Benefits of This Approach

- **High Maintainability:** To add or change logic, developers add or update rows in the `_workflow_transitions` table and create small, isolated handler functions. The core engine remains untouched.
- **Clarity & Self-Documentation:** The `_workflow_transitions` table provides a clear, high-level blueprint of the entire system's logic.
- **Scalability:** The system can scale to dozens of stage types and events without increasing the complexity of the core engine.
- **Robustness:** It inherits the full transactional integrity of PostgreSQL, preventing tasks from getting stuck in inconsistent states.
